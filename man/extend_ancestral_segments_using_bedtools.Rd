% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/extend_ancestral_segs_using_bedtools.R
\name{extend_ancestral_segments_using_bedtools}
\alias{extend_ancestral_segments_using_bedtools}
\title{extend ancestral segments with three species using bedtools}
\usage{
extend_ancestral_segments_using_bedtools(X, species_levels, TMP = tempfile())
}
\arguments{
\item{X}{a tibble like that which comes out of \code{ancestral_n_segments()}.
It has columns of:
\itemize{
\item \code{diag_spp}: character name of the species the 1 allele at the
marker is diagnostic for
\item \code{indiv}: character individuals ID
\item \code{chrom}: character chromosome name
\item \code{chrom_f}: a factor of the chromosome names for proper sorting
\item \code{n}: integer number of doses of the ancestry in the segment
\item \code{n_f}: a factor of n.
\item \code{start}: the starting position (base-1 indexed of the interval)
\item \code{stop}: the ending position of the interval.
}}

\item{species_levels}{a character vector giving the names of the ancestries
in the order that you want them to be considered (essentially the levels of a
factor), like \code{c("WCT", "RBT", "YCT")}}

\item{TMP}{temp directory in which to run bedtools.  Defaults to a tempfile().
Setting it manually can be useful for development and debugging.}
}
\description{
This is a function to extend the ancestral segments using
bedtools.  It is more general, and I hope, much faster than
the previous approach I used with the intervals package, which is
incredibly slow.
}
\details{
This is more general because it can accommodate any number of
ancestries, though I have only really implemented it with three
ancestries.

Running only on a single core this function is about 30 times faster
than \code{extend_ancestral_segmentes_3()}, even when the latter function is running on 8 cores.
I checked the output on some test cases and this gives nearly identical results to
\code{extend_ancestral_segmentes_3()}, with the differences being one or two small
segments, and start and stop positions moved by 1 in some cases.  But overall it is
pretty much the same, and WAY faster.
}
