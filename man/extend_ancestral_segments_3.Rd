% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/extend_ancestral_segments_3.R
\name{extend_ancestral_segments_3}
\alias{extend_ancestral_segments_3}
\title{Extend segments found by \code{ancestral_n_segments} for scenarios with three ancestries}
\usage{
extend_ancestral_segments_3(D, diag_spp_levels)
}
\arguments{
\item{D}{a tibble like that which comes out of function ancestral_n_segments.
It is crucial that it has these columns:
\itemize{
\item \code{diag_spp}: a character vector of the codes/names of which species the marker
is diagnostic for.
\item \code{indiv}: the sample ID for the individual.
\item \code{chrom_f}: the chromosome as a factor with levels from \code{chrom_levels}
\item \code{n}: the number of copies of the species-diagnostic allele
\item \code{start}: the position of the marker at which the segment begins.
\item \code{stop}: the position of the marker at which the segement ends
}}

\item{diag_spp_levels}{a vector that will be used to turn the
\code{diag_spp} column into a factor, which will then define species A, B, and C.
For the example this package was made for it would be, for example,
\code{c("WCT", "RBT", "YCT")}.}
}
\description{
This function uses the interval arithmetic to come up with segments of different
copy numbers of the three ancestries that we will call A, B, and C within the
function.  In the process, it stores all the intervals/segments as Intervals
objects from the 'intervals' package.
}
\details{
This function relies heavily an nesting.
}
